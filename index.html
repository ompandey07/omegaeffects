<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmegaEffects - Sudarshan Chakra</title>
  <link rel="shortcut icon" href="helmet.png" type="image/x-icon">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Georgia', serif; }
    
    video {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: scaleX(-1);
    }
    
    #overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(ellipse at center, 
        rgba(0,0,0,0.15) 0%, 
        rgba(0,0,0,0.35) 50%, 
        rgba(0,0,0,0.6) 100%);
      pointer-events: none;
      z-index: 1;
    }
    
    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
    }
    
    #fx { z-index: 10; }
    #glow { z-index: 5; filter: blur(25px); opacity: 0.6; }
    #sparks { z-index: 15; }
    #eyes { z-index: 20; }
    
    .loading {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, #0a0a15, #000);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s ease-out;
    }
    
    .loading.hide { opacity: 0; pointer-events: none; }
    
    .loader {
      width: 100px; height: 100px;
      border: 4px solid transparent;
      border-top: 4px solid #ffcc44;
      border-right: 4px solid #ffaa22;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      box-shadow: 0 0 30px rgba(255,180,50,0.5);
      position: relative;
    }
    
    .loader::before {
      content: '';
      position: absolute;
      inset: 10px;
      border: 3px solid transparent;
      border-bottom: 3px solid #ff8800;
      border-left: 3px solid #ffdd66;
      border-radius: 50%;
      animation: spin 1.2s linear reverse infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }
    
    .loading p { 
      color: #ffcc44; 
      margin-top: 30px; 
      font-size: 16px; 
      letter-spacing: 6px; 
      text-shadow: 0 0 20px rgba(255,180,50,0.5);
    }
    
    #hud {
      position: fixed;
      top: 15px; left: 15px;
      color: #0f0;
      font: bold 14px monospace;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid rgba(0,255,0,0.3);
    }
    
    #tips {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font: 13px Georgia;
      background: rgba(0,0,0,0.85);
      padding: 12px 25px;
      border-radius: 25px;
      z-index: 100;
      border: 1px solid rgba(255,180,50,0.4);
      text-align: center;
      max-width: 95vw;
    }
    
    #tips span { color: #ffcc44; font-weight: bold; }
    #tips .fire { color: #ff6644; }
    
    #gesture {
      position: fixed;
      top: 15px;
      right: 15px;
      color: #ffcc44;
      font: bold 14px monospace;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255,180,50,0.3);
    }
    
    #powerMeter {
      position: fixed;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      width: 250px;
      height: 6px;
      background: rgba(0,0,0,0.7);
      border-radius: 3px;
      border: 1px solid rgba(100,180,255,0.4);
      z-index: 100;
      overflow: hidden;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #powerMeter.active { opacity: 1; }
    
    #powerFill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2a5a7a, #3a7a9a, #4a9aba, #6abadb, #8adaff);
      border-radius: 3px;
      transition: width 0.1s;
      box-shadow: 0 0 15px rgba(60,140,180,0.6);
    }
  </style>
</head>
<body>

<div class="loading" id="loader">
  <div class="loader"></div>
  <p>‡•• ‡§∏‡•Å‡§¶‡§∞‡•ç‡§∂‡§® ‡§ö‡§ï‡•ç‡§∞ ‡••</p>
</div>

<div id="hud">FPS: <span id="fps">0</span></div>
<div id="gesture">Gesture: <span id="gestureType">None</span></div>

<div id="powerMeter">
  <div id="powerFill"></div>
</div>

<div id="tips">
  <span>‚òùÔ∏è Point</span> = üî• Sudarshan Chakra &nbsp;|&nbsp;
  <span class="fire">üñêÔ∏èüñêÔ∏è Both Palms</span> = Fire Shields + Red Eyes &nbsp;|&nbsp;
  <span>‚òùÔ∏è‚òùÔ∏è Both Point</span> = üåä Divine Energy ‚Üí Throw = üí• Blast
</div>

<video id="cam" playsinline></video>
<div id="overlay"></div>
<canvas id="glow"></canvas>
<canvas id="fx"></canvas>
<canvas id="sparks"></canvas>
<canvas id="eyes"></canvas>

<script>
// === AUDIO SYSTEM ===
class AudioSystem {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.shieldPlaying = { left: false, right: false };
    this.energyOsc = null;
    this.chakraOsc = null;
  }
  
  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch(e) {}
  }
  
  playChakraSound() {
    if (!this.initialized || !this.ctx || this.chakraOsc) return;
    
    const now = this.ctx.currentTime;
    this.chakraOsc = { oscs: [], master: this.ctx.createGain() };
    
    // Divine humming sound
    [110, 220, 330, 440].forEach((freq, i) => {
      const osc = this.ctx.createOscillator();
      osc.type = i === 0 ? 'sine' : 'triangle';
      osc.frequency.value = freq;
      osc.connect(this.chakraOsc.master);
      osc.start(now);
      this.chakraOsc.oscs.push(osc);
    });
    
    this.chakraOsc.master.gain.setValueAtTime(0, now);
    this.chakraOsc.master.gain.linearRampToValueAtTime(0.08, now + 0.3);
    this.chakraOsc.master.connect(this.ctx.destination);
  }
  
  updateChakraSound(intensity) {
    if (!this.chakraOsc) return;
    this.chakraOsc.master.gain.value = intensity * 0.08;
    this.chakraOsc.oscs.forEach((osc, i) => {
      osc.frequency.value = [110, 220, 330, 440][i] * (1 + Math.sin(Date.now() * 0.003) * 0.02);
    });
  }
  
  stopChakraSound() {
    if (!this.chakraOsc) return;
    const now = this.ctx.currentTime;
    this.chakraOsc.master.gain.linearRampToValueAtTime(0, now + 0.2);
    setTimeout(() => {
      if (this.chakraOsc) {
        this.chakraOsc.oscs.forEach(osc => { try { osc.stop(); } catch(e) {} });
        this.chakraOsc = null;
      }
    }, 200);
  }
  
  playShieldSound(side) {
    if (!this.initialized || !this.ctx || this.shieldPlaying[side]) return;
    this.shieldPlaying[side] = true;
    
    const now = this.ctx.currentTime;
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const masterGain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    osc1.type = 'sine'; osc1.frequency.setValueAtTime(80, now); osc1.frequency.exponentialRampToValueAtTime(120, now + 0.3);
    osc2.type = 'triangle'; osc2.frequency.setValueAtTime(200, now); osc2.frequency.exponentialRampToValueAtTime(300, now + 0.2);
    
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(1500, now); filter.Q.value = 2;
    masterGain.gain.setValueAtTime(0, now); masterGain.gain.linearRampToValueAtTime(0.12, now + 0.05); masterGain.gain.linearRampToValueAtTime(0, now + 0.5);
    
    osc1.connect(filter); osc2.connect(filter);
    filter.connect(masterGain); masterGain.connect(this.ctx.destination);
    
    osc1.start(now); osc2.start(now);
    osc1.stop(now + 0.5); osc2.stop(now + 0.5);
    
    setTimeout(() => { this.shieldPlaying[side] = false; }, 500);
  }
  
  startEnergySound() {
    if (!this.initialized || !this.ctx || this.energyOsc) return;
    const now = this.ctx.currentTime;
    this.energyOsc = { oscs: [], master: this.ctx.createGain() };
    
    [120, 180, 250].forEach((freq, i) => {
      const osc = this.ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc.connect(this.energyOsc.master);
      osc.start(now);
      this.energyOsc.oscs.push(osc);
    });
    
    this.energyOsc.master.gain.value = 0;
    this.energyOsc.master.connect(this.ctx.destination);
  }
  
  updateEnergySound(intensity) {
    if (!this.energyOsc) return;
    this.energyOsc.master.gain.value = intensity * 0.06;
    this.energyOsc.oscs.forEach((osc, i) => {
      osc.frequency.value = [120, 180, 250][i] + Math.sin(Date.now() * 0.004 + i) * 12 * intensity;
    });
  }
  
  stopEnergySound() {
    if (!this.energyOsc) return;
    const now = this.ctx.currentTime;
    this.energyOsc.master.gain.linearRampToValueAtTime(0, now + 0.12);
    setTimeout(() => {
      if (this.energyOsc) {
        this.energyOsc.oscs.forEach(osc => { try { osc.stop(); } catch(e) {} });
        this.energyOsc = null;
      }
    }, 120);
  }
  
  playExplosionSound(power) {
    if (!this.initialized || !this.ctx) return;
    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100 * power, now); osc.frequency.exponentialRampToValueAtTime(25, now + 0.25);
    gain.gain.setValueAtTime(0.2 * power, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
    osc.connect(gain); gain.connect(this.ctx.destination);
    osc.start(now); osc.stop(now + 0.35);
  }
}

const audio = new AudioSystem();
document.addEventListener('click', () => audio.init(), { once: true });
document.addEventListener('touchstart', () => audio.init(), { once: true });

// === CONFIG ===
const CONFIG = {
  MAX_PARTICLES: 400,
  MAX_SPARKS: 350,
  MAX_EMBERS: 300,
  MAX_LIGHTNING: 35,
  MANDALA_SEGMENTS: 24,
  CHAKRA_BLADES: 108,
  CHAKRA_SIZE: 120
};

const SANSKRIT = '‡•ê ‡§∂‡•ç‡§∞‡•Ä ‡§ï‡•É‡§∑‡•ç‡§£ ‡§∏‡•Å‡§¶‡§∞‡•ç‡§∂‡§® ‡§®‡§Æ‡§É ‡§µ‡§ø‡§∑‡•ç‡§£‡•Å ‡§π‡§∞‡§ø';
const RUNES = '·ö†·ö¢·ö¶·ö®·ö±·ö≤·ö∑·öπ·ö∫·öæ·õÅ·õÉ·õá·õà·õâ·õä·õè·õí·õñ·õó·õö·õú·õû·õü·ö™·ö´·ö£·õ†';
const SACRED = '‚òØ‚ò∏‚ú°‚öõ‚öï‚ôæ‚àû‚óé‚äï‚äó‚äô‚óâ‚¶ø‚äö‚äõ‚äú‚äù';

// === SETUP ===
const cam = document.getElementById('cam');
const fx = document.getElementById('fx');
const glow = document.getElementById('glow');
const sparksCanvas = document.getElementById('sparks');
const eyesCanvas = document.getElementById('eyes');
const c = fx.getContext('2d');
const g = glow.getContext('2d');
const s = sparksCanvas.getContext('2d');
const e = eyesCanvas.getContext('2d');

let W, H;
function resize() {
  W = innerWidth; H = innerHeight;
  fx.width = W; fx.height = H;
  sparksCanvas.width = W; sparksCanvas.height = H;
  eyesCanvas.width = W; eyesCanvas.height = H;
  glow.width = W >> 1; glow.height = H >> 1;
}
resize();
addEventListener('resize', resize);

// === STATE ===
let time = 0;
let leftHand = null, rightHand = null;
let leftData = null, rightData = null;
let prevLeftPos = null, prevRightPos = null;
let faceData = null;
let leftEyeData = null, rightEyeData = null;

let particles = [];
let sparks = [];
let embers = [];
let lightnings = [];
let shockwaves = [];

let flash = 0, shake = 0;
let pullState = { active: false, distance: 0, energy: 0, peakEnergy: 0, wasActive: false };
let leftShieldActive = false, rightShieldActive = false;
let frames = 0, lastSec = 0;

// Sudarshan Chakra state
let leftChakra = null;
let rightChakra = null;
let leftChakraActive = false;
let rightChakraActive = false;

// Eye state
let bothEyesRedIntensity = 0;

// === HAND DATA ===
function getHandData(landmarks) {
  if (!landmarks) return null;
  
  const palm = landmarks[9];
  const wrist = landmarks[0];
  const thumb = landmarks[4];
  const index = landmarks[8];
  const middle = landmarks[12];
  const ring = landmarks[16];
  const pinky = landmarks[20];
  
  const fingerTips = [thumb, index, middle, ring, pinky];
  const fingersExtended = [];
  
  const thumbExtended = Math.abs(thumb.x - wrist.x) > Math.abs(landmarks[2].x - wrist.x) * 1.2;
  fingersExtended.push(thumbExtended);
  
  for (let i = 1; i < 5; i++) {
    const tipY = fingerTips[i].y;
    const pipY = landmarks[5 + (i-1) * 4 + 1].y;
    fingersExtended.push(tipY < pipY - 0.02);
  }
  
  const extendedCount = fingersExtended.filter(Boolean).length;
  
  let gesture = 'none';
  if (extendedCount === 0) gesture = 'fist';
  else if (extendedCount === 1 && fingersExtended[1]) gesture = 'pointing';
  else if (extendedCount >= 4) gesture = 'openPalm';
  else gesture = 'partial';
  
  const palmPos = { x: (1 - palm.x) * W, y: palm.y * H };
  const indexPos = { x: (1 - index.x) * W, y: index.y * H };
  const palmSize = Math.hypot((landmarks[5].x - landmarks[17].x) * W, (landmarks[5].y - landmarks[17].y) * H);
  
  return { palm: palmPos, index: indexPos, gesture, palmSize, fingersExtended };
}

// === EYE DATA ===
function getDetailedEyeData(faceLandmarks) {
  if (!faceLandmarks) return { left: null, right: null };
  
  const leftContour = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
  const leftIris = [468, 469, 470, 471, 472];
  const rightContour = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
  const rightIris = [473, 474, 475, 476, 477];
  
  function processEye(contourIdx, irisIdx) {
    let cx = 0, cy = 0, minX = 1, maxX = 0;
    contourIdx.forEach(i => {
      const p = faceLandmarks[i];
      cx += p.x; cy += p.y;
      minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
    });
    cx = (1 - cx / contourIdx.length) * W;
    cy = (cy / contourIdx.length) * H;
    const width = (maxX - minX) * W;
    
    let irisX = cx, irisY = cy, irisSize = width * 0.35;
    if (irisIdx && faceLandmarks[irisIdx[0]]) {
      let ix = 0, iy = 0;
      irisIdx.forEach(i => { if (faceLandmarks[i]) { ix += faceLandmarks[i].x; iy += faceLandmarks[i].y; } });
      irisX = (1 - ix / irisIdx.length) * W;
      irisY = (iy / irisIdx.length) * H;
    }
    const contourPoints = contourIdx.map(i => ({ x: (1 - faceLandmarks[i].x) * W, y: faceLandmarks[i].y * H }));
    return { irisX, irisY, irisSize, contour: contourPoints };
  }
  
  return { left: processEye(leftContour, leftIris), right: processEye(rightContour, rightIris) };
}

// === PARTICLES ===
function addParticle(x, y, vx, vy, size, life, hue) {
  if (particles.length >= CONFIG.MAX_PARTICLES) particles.shift();
  particles.push({ x, y, vx, vy, size, life, maxLife: life, hue, flickerPhase: Math.random() * Math.PI * 2 });
}

function addSpark(x, y, vx, vy, hue, size = 3) {
  if (sparks.length >= CONFIG.MAX_SPARKS) sparks.shift();
  sparks.push({ x, y, vx, vy, life: 1, hue, size, trail: [{ x, y }], flickerSpeed: 5 + Math.random() * 10 });
}

function addEmber(x, y, vx, vy, hue = null) {
  if (embers.length >= CONFIG.MAX_EMBERS) embers.shift();
  embers.push({ x, y, vx, vy, life: 1, size: 2 + Math.random() * 4, hue: hue !== null ? hue : 25 + Math.random() * 25, wobble: Math.random() * Math.PI * 2, wobbleSpeed: 2 + Math.random() * 3 });
}

function addLightning(x1, y1, x2, y2, branches = 3, hue = 200) {
  if (lightnings.length >= CONFIG.MAX_LIGHTNING) lightnings.shift();
  lightnings.push({ points: generateLightningPoints(x1, y1, x2, y2, branches), life: 1, hue });
}

function addShockwave(x, y, maxR, color) {
  shockwaves.push({ x, y, r: 0, maxR, life: 1, color });
}

function generateLightningPoints(x1, y1, x2, y2, depth) {
  if (depth === 0) return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
  const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * Math.abs(x2 - x1) * 0.35;
  const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * Math.abs(y2 - y1) * 0.35;
  const left = generateLightningPoints(x1, y1, midX, midY, depth - 1);
  const right = generateLightningPoints(midX, midY, x2, y2, depth - 1);
  return [...left, ...right.slice(1)];
}

// === SUDARSHAN CHAKRA CLASS ===
class SudarshanChakra {
  constructor(x, y, isLeft) {
    this.x = x;
    this.y = y;
    this.targetX = x;
    this.targetY = y;
    this.size = 20;
    this.targetSize = CONFIG.CHAKRA_SIZE;
    this.rotation = 0;
    this.innerRotation = 0;
    this.life = 0;
    this.isLeft = isLeft;
    this.active = true;
    this.flamePhase = Math.random() * Math.PI * 2;
    this.pulsePhase = Math.random() * Math.PI * 2;
  }
  
  update(x, y, active) {
    this.targetX = x;
    this.targetY = y;
    this.active = active;
    
    // Smooth position interpolation
    this.x += (this.targetX - this.x) * 0.3;
    this.y += (this.targetY - this.y) * 0.3;
    
    // High speed rotation
    this.rotation += 0.25;
    this.innerRotation -= 0.15;
    
    if (active) {
      this.size += (this.targetSize - this.size) * 0.15;
      this.life = Math.min(1, this.life + 0.1);
    } else {
      this.life -= 0.08;
      this.size *= 0.9;
    }
    
    // Emit divine sparks
    if (active && Math.random() < 0.6) {
      const angle = Math.random() * Math.PI * 2;
      const dist = this.size * 0.9;
      const sparkX = this.x + Math.cos(angle + this.rotation) * dist;
      const sparkY = this.y + Math.sin(angle + this.rotation) * dist;
      const speed = 8 + Math.random() * 6;
      addSpark(sparkX, sparkY, 
        Math.cos(angle + this.rotation) * speed, 
        Math.sin(angle + this.rotation) * speed, 
        30 + Math.random() * 20, 2);
    }
    
    // Emit flames
    if (active && Math.random() < 0.4) {
      const angle = Math.random() * Math.PI * 2;
      const dist = this.size * 0.7;
      addEmber(
        this.x + Math.cos(angle) * dist,
        this.y + Math.sin(angle) * dist,
        (Math.random() - 0.5) * 4,
        -3 - Math.random() * 4,
        20 + Math.random() * 25
      );
    }
  }
  
  draw(ctx) {
    if (this.life <= 0 || this.size < 5) return;
    
    const { x, y, size, rotation, innerRotation, life } = this;
    const pulse = 1 + Math.sin(time * 6 + this.pulsePhase) * 0.05;
    const r = size * pulse;
    
    ctx.save();
    ctx.globalAlpha = Math.min(1, life * 1.5);
    ctx.translate(x, y);
    
    // Outer divine glow
    for (let i = 4; i >= 0; i--) {
      const glowSize = r * (1.5 + i * 0.3);
      const gradient = ctx.createRadialGradient(0, 0, r * 0.3, 0, 0, glowSize);
      gradient.addColorStop(0, `hsla(45, 100%, 70%, ${life * 0.15 * (1 - i * 0.15)})`);
      gradient.addColorStop(0.5, `hsla(35, 100%, 55%, ${life * 0.1 * (1 - i * 0.2)})`);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Flames around the chakra
    ctx.save();
    ctx.rotate(rotation * 0.3);
    const flameCount = 36;
    for (let i = 0; i < flameCount; i++) {
      const angle = (i / flameCount) * Math.PI * 2;
      const flicker = Math.sin(time * 15 + i * 1.5 + this.flamePhase) * 0.4 + 0.6;
      const flameHeight = (25 + Math.sin(time * 10 + i * 2) * 10) * flicker * (r / CONFIG.CHAKRA_SIZE);
      
      ctx.save();
      ctx.rotate(angle);
      ctx.translate(r * 0.95, 0);
      ctx.rotate(Math.PI / 2);
      
      // Multi-layer flame
      for (let layer = 0; layer < 3; layer++) {
        const layerHeight = flameHeight * (1 - layer * 0.25);
        const gradient = ctx.createLinearGradient(0, 0, 0, layerHeight);
        const alpha = (1 - layer * 0.3) * life * flicker;
        
        gradient.addColorStop(0, `hsla(${50 - layer * 10}, 100%, ${95 - layer * 10}%, ${alpha})`);
        gradient.addColorStop(0.3, `hsla(${40 - layer * 8}, 100%, ${75 - layer * 15}%, ${alpha * 0.8})`);
        gradient.addColorStop(0.7, `hsla(${25 - layer * 5}, 100%, ${55 - layer * 10}%, ${alpha * 0.4})`);
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        const w = 6 - layer * 1.5;
        ctx.moveTo(-w, 0);
        ctx.bezierCurveTo(-w * 0.5, layerHeight * 0.3, -w * 0.2, layerHeight * 0.7, 0, layerHeight);
        ctx.bezierCurveTo(w * 0.2, layerHeight * 0.7, w * 0.5, layerHeight * 0.3, w, 0);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();
    
    // Main rotating disc with blades
    ctx.save();
    ctx.rotate(rotation);
    
    // Outer blade ring
    const bladeCount = CONFIG.CHAKRA_BLADES;
    for (let i = 0; i < bladeCount; i++) {
      const angle = (i / bladeCount) * Math.PI * 2;
      const bladeGlow = Math.sin(time * 8 + i * 0.3) * 0.3 + 0.7;
      
      ctx.save();
      ctx.rotate(angle);
      
      // Sharp blade shape
      const gradient = ctx.createLinearGradient(r * 0.5, 0, r, 0);
      gradient.addColorStop(0, `hsla(45, 100%, 80%, ${life * bladeGlow})`);
      gradient.addColorStop(0.5, `hsla(40, 100%, 60%, ${life * bladeGlow * 0.8})`);
      gradient.addColorStop(1, `hsla(35, 100%, 95%, ${life * bladeGlow})`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(r * 0.5, 0);
      ctx.lineTo(r * 0.95, -3);
      ctx.lineTo(r, 0);
      ctx.lineTo(r * 0.95, 3);
      ctx.closePath();
      ctx.fill();
      
      // Blade edge highlight
      ctx.strokeStyle = `hsla(50, 100%, 95%, ${life * bladeGlow * 0.6})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
      
      ctx.restore();
    }
    
    // Middle ring
    ctx.strokeStyle = `hsla(45, 100%, 75%, ${life})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = `hsla(40, 100%, 60%, 0.8)`;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Inner rotating rings
    for (let ring = 0; ring < 3; ring++) {
      const ringR = r * (0.35 - ring * 0.08);
      const ringAlpha = (1 - ring * 0.25) * life;
      
      ctx.save();
      ctx.rotate(innerRotation * (ring % 2 ? 1 : -1) * (1 + ring * 0.5));
      
      ctx.strokeStyle = `hsla(${50 - ring * 5}, 100%, ${70 - ring * 10}%, ${ringAlpha})`;
      ctx.lineWidth = 2 - ring * 0.5;
      ctx.setLineDash([ringR * 0.15, ringR * 0.05]);
      ctx.lineDashOffset = time * 40 * (ring % 2 ? 1 : -1);
      ctx.beginPath();
      ctx.arc(0, 0, ringR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.restore();
    }
    
    ctx.restore();
    
    // Central divine core
    ctx.save();
    ctx.rotate(-rotation * 0.5);
    
    // Core glow
    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.25);
    coreGrad.addColorStop(0, `hsla(50, 100%, 98%, ${life})`);
    coreGrad.addColorStop(0.3, `hsla(45, 100%, 80%, ${life * 0.9})`);
    coreGrad.addColorStop(0.6, `hsla(40, 100%, 60%, ${life * 0.6})`);
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.25, 0, Math.PI * 2);
    ctx.fill();
    
    // OM symbol in center
    ctx.font = `bold ${r * 0.18}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = `hsla(30, 100%, 30%, ${life})`;
    ctx.shadowColor = `hsla(45, 100%, 70%, ${life})`;
    ctx.shadowBlur = 10;
    ctx.fillText('‡•ê', 0, 0);
    ctx.shadowBlur = 0;
    
    ctx.restore();
    
    // Decorative Sanskrit around outer edge
    ctx.save();
    ctx.rotate(rotation * 0.2);
    ctx.font = `${r * 0.06}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    const chars = SANSKRIT.split('');
    for (let i = 0; i < chars.length; i++) {
      const angle = (i / chars.length) * Math.PI * 2;
      const charR = r * 0.7;
      const glow = Math.sin(time * 3 + i * 0.4) * 0.3 + 0.7;
      
      ctx.save();
      ctx.rotate(angle);
      ctx.translate(charR, 0);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = `hsla(45, 100%, ${60 + glow * 30}%, ${life * glow})`;
      ctx.fillText(chars[i], 0, 0);
      ctx.restore();
    }
    ctx.restore();
    
    // Six-pointed star (Shatkona)
    ctx.save();
    ctx.rotate(innerRotation);
    ctx.strokeStyle = `hsla(45, 100%, 75%, ${life * 0.8})`;
    ctx.lineWidth = 2;
    
    // Upward triangle
    ctx.beginPath();
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
      const px = Math.cos(angle) * r * 0.4;
      const py = Math.sin(angle) * r * 0.4;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    
    // Downward triangle
    ctx.beginPath();
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2 + Math.PI / 2;
      const px = Math.cos(angle) * r * 0.4;
      const py = Math.sin(angle) * r * 0.4;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    
    ctx.restore();
    
    // Glow layer
    g.fillStyle = `hsla(40, 100%, 50%, ${life * 0.5})`;
    g.beginPath();
    g.arc(x / 2, y / 2, r / 2, 0, Math.PI * 2);
    g.fill();
  }
}

// === DRAW RED EYE GLOW ===
function drawRedGlowingEye(eyeData, ctx, intensity) {
  if (!eyeData || intensity < 0.01) return;
  
  const { irisX, irisY, irisSize, contour } = eyeData;
  const flickerVal = Math.sin(time * 25) * 0.1 + 0.9;
  const pulseVal = Math.sin(time * 4) * 0.05 + 1;
  
  ctx.save();
  ctx.beginPath();
  if (contour && contour.length > 0) {
    ctx.moveTo(contour[0].x, contour[0].y);
    for (let i = 1; i < contour.length; i++) ctx.lineTo(contour[i].x, contour[i].y);
    ctx.closePath();
    ctx.clip();
  }
  
  const baseGlow = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize * 1.5);
  baseGlow.addColorStop(0, `hsla(0, 100%, 88%, ${intensity * 0.85 * flickerVal})`);
  baseGlow.addColorStop(0.25, `hsla(5, 100%, 65%, ${intensity * 0.7 * flickerVal})`);
  baseGlow.addColorStop(0.5, `hsla(0, 100%, 42%, ${intensity * 0.45})`);
  baseGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = baseGlow;
  ctx.beginPath();
  ctx.ellipse(irisX, irisY, irisSize * 1.5, irisSize * 1.3, 0, 0, Math.PI * 2);
  ctx.fill();
  
  const irisGlow = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize * pulseVal);
  irisGlow.addColorStop(0, `hsla(15, 100%, 92%, ${intensity})`);
  irisGlow.addColorStop(0.5, `hsla(5, 100%, 65%, ${intensity * 0.7})`);
  irisGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = irisGlow;
  ctx.beginPath();
  ctx.arc(irisX, irisY, irisSize * pulseVal, 0, Math.PI * 2);
  ctx.fill();
  
  const pupilGlow = ctx.createRadialGradient(irisX, irisY, 0, irisX, irisY, irisSize * 0.32);
  pupilGlow.addColorStop(0, `hsla(20, 100%, 98%, ${intensity})`);
  pupilGlow.addColorStop(0.7, `hsla(10, 100%, 75%, ${intensity * 0.6})`);
  pupilGlow.addColorStop(1, `hsla(5, 100%, 50%, ${intensity * 0.25})`);
  ctx.fillStyle = pupilGlow;
  ctx.beginPath();
  ctx.arc(irisX, irisY, irisSize * 0.32, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
  
  const outerGlow = ctx.createRadialGradient(irisX, irisY, irisSize * 0.4, irisX, irisY, irisSize * 2);
  outerGlow.addColorStop(0, `hsla(0, 100%, 48%, ${intensity * 0.08})`);
  outerGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = outerGlow;
  ctx.beginPath();
  ctx.arc(irisX, irisY, irisSize * 2, 0, Math.PI * 2);
  ctx.fill();
  
  g.fillStyle = `hsla(0, 100%, 42%, ${intensity * 0.15})`;
  g.beginPath();
  g.arc(irisX / 2, irisY / 2, irisSize * 0.6, 0, Math.PI * 2);
  g.fill();
}

// === BLAST EXPLOSION ===
function triggerExplosion(x, y, power) {
  audio.playExplosionSound(power);
  
  addShockwave(x, y, 220 * power, { h: 45, s: 100, l: 50 });
  addShockwave(x, y, 300 * power, { h: 35, s: 100, l: 40 });
  addShockwave(x, y, 380 * power, { h: 25, s: 100, l: 30 });
  
  for (let i = 0; i < Math.floor(90 * power); i++) {
    const angle = (i / 90) * Math.PI * 2 + Math.random() * 0.35;
    const speed = (14 + Math.random() * 28) * power;
    const hue = 30 + Math.random() * 30;
    const size = 10 + Math.random() * 18;
    addParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, size, 0.85 + Math.random() * 0.4, hue);
  }
  
  for (let i = 0; i < Math.floor(70 * power); i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 18 + Math.random() * 35;
    const hue = 25 + Math.random() * 35;
    addSpark(x, y, Math.cos(angle) * speed * power, Math.sin(angle) * speed * power, hue, 2.5 + Math.random() * 2);
  }
  
  for (let i = 0; i < Math.floor(50 * power); i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * 35;
    const speed = 4 + Math.random() * 10;
    addEmber(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist, Math.cos(angle) * speed, Math.sin(angle) * speed - 2.5, 30 + Math.random() * 25);
  }
  
  for (let i = 0; i < Math.floor(12 * power); i++) {
    const angle = (i / 12) * Math.PI * 2 + Math.random() * 0.6;
    const dist = 120 + Math.random() * 180;
    addLightning(x, y, x + Math.cos(angle) * dist, y + Math.sin(angle) * dist, 4, 40 + Math.random() * 20);
  }
  
  flash = power * 0.75;
  shake = 45 * power;
}

// === RED MANDALA ===
class Mandala {
  constructor(x, y, size, isLeft) {
    this.x = x; this.y = y;
    this.size = size * 0.5;
    this.targetSize = size;
    this.rot = 0; this.life = 0.8;
    this.isLeft = isLeft; this.active = true;
  }
  
  update(x, y, size, active) {
    this.x = x; this.y = y;
    this.targetSize = size;
    this.active = active;
    this.rot += 0.05;
    
    if (active) {
      this.size += (this.targetSize - this.size) * 0.3;
      this.life = Math.min(1, this.life + 0.2);
    } else {
      this.life -= 0.06;
      this.size *= 0.92;
    }
    
    if (active && Math.random() < 0.5) {
      const angle = Math.random() * Math.PI * 2;
      addEmber(this.x + Math.cos(angle) * this.size * 0.95, this.y + Math.sin(angle) * this.size * 0.95, Math.cos(angle) * 3, Math.sin(angle) * 3 - 1, Math.random() * 15);
    }
  }
  
  draw() {
    if (this.life <= 0 || this.size < 10) return;
    const { x, y, size, rot, life } = this;
    
    c.save();
    c.globalAlpha = life;
    c.translate(x, y);
    
    const outerGlow = c.createRadialGradient(0, 0, size * 0.6, 0, 0, size * 1.4);
    outerGlow.addColorStop(0, 'transparent');
    outerGlow.addColorStop(0.5, `hsla(0, 100%, 40%, 0.25)`);
    outerGlow.addColorStop(1, 'transparent');
    c.fillStyle = outerGlow;
    c.beginPath();
    c.arc(0, 0, size * 1.4, 0, Math.PI * 2);
    c.fill();
    
    c.save();
    c.rotate(rot);
    for (let layer = 0; layer <= 3; layer++) {
      const layerSize = size * (1 - layer * 0.2);
      c.strokeStyle = `hsla(${layer * 5}, 100%, ${60 - layer * 8}%, ${life * (1 - layer * 0.2)})`;
      c.lineWidth = 3 - layer * 0.5;
      c.shadowColor = `hsla(0, 100%, 50%, 0.5)`;
      c.shadowBlur = layer === 0 ? 15 : 0;
      c.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const hx = Math.cos(a) * layerSize * 0.95;
        const hy = Math.sin(a) * layerSize * 0.95;
        i === 0 ? c.moveTo(hx, hy) : c.lineTo(hx, hy);
      }
      c.closePath();
      c.stroke();
      c.shadowBlur = 0;
      c.rotate(Math.PI / 12);
    }
    c.restore();
    
    c.save();
    c.rotate(-rot * 1.5);
    for (let i = 0; i < 2; i++) {
      c.rotate(Math.PI / 6);
      c.strokeStyle = `hsla(5, 100%, 65%, ${life * 0.8})`;
      c.lineWidth = 2;
      c.beginPath();
      for (let j = 0; j < 3; j++) {
        const ta = (j / 3) * Math.PI * 2 - Math.PI / 2;
        const tx = Math.cos(ta) * size * 0.6;
        const ty = Math.sin(ta) * size * 0.6;
        j === 0 ? c.moveTo(tx, ty) : c.lineTo(tx, ty);
      }
      c.closePath();
      c.stroke();
    }
    c.restore();
    
    c.save();
    c.rotate(rot * 0.5);
    for (let i = 0; i < 4; i++) {
      const cr = size * (0.3 + i * 0.15);
      c.strokeStyle = `hsla(${i * 3}, 100%, ${60 - i * 8}%, ${life * (0.8 - i * 0.15)})`;
      c.lineWidth = 2 - i * 0.3;
      c.setLineDash([cr * 0.1, cr * 0.05]);
      c.lineDashOffset = time * 30 * (i % 2 ? 1 : -1);
      c.beginPath();
      c.arc(0, 0, cr, 0, Math.PI * 2);
      c.stroke();
      c.setLineDash([]);
    }
    c.restore();
    
    c.save();
    c.rotate(-rot * 0.3);
    c.font = `bold ${size * 0.08}px Georgia`;
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    
    for (let i = 0; i < CONFIG.MANDALA_SEGMENTS; i++) {
      const a = (i / CONFIG.MANDALA_SEGMENTS) * Math.PI * 2;
      const rx = Math.cos(a) * size * 0.8;
      const ry = Math.sin(a) * size * 0.8;
      const glow = Math.sin(time * 4 + i) * 0.3 + 0.7;
      c.fillStyle = `hsla(${5 + glow * 10}, 100%, ${60 + glow * 25}%, ${life * glow})`;
      c.shadowColor = `hsla(0, 100%, 50%, ${life})`;
      c.shadowBlur = 8;
      c.fillText(RUNES[i % RUNES.length], rx, ry);
    }
    c.shadowBlur = 0;
    c.restore();
    
    const centerGrad = c.createRadialGradient(0, 0, 0, 0, 0, size * 0.25);
    centerGrad.addColorStop(0, `hsla(10, 100%, 90%, ${life})`);
    centerGrad.addColorStop(0.5, `hsla(0, 100%, 60%, ${life * 0.6})`);
    centerGrad.addColorStop(1, 'transparent');
    c.fillStyle = centerGrad;
    c.beginPath();
    c.arc(0, 0, size * 0.25, 0, Math.PI * 2);
    c.fill();
    
    c.font = `${size * 0.15}px serif`;
    c.fillStyle = `hsla(10, 100%, 90%, ${life})`;
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    c.fillText(SACRED[Math.floor(time) % SACRED.length], 0, 0);
    
    c.save();
    c.rotate(rot * 2);
    for (let i = 0; i < 12; i++) {
      const sa = (i / 12) * Math.PI * 2;
      const gradient = c.createLinearGradient(0, 0, Math.cos(sa) * size, Math.sin(sa) * size);
      gradient.addColorStop(0, `hsla(10, 100%, 70%, ${life * 0.8})`);
      gradient.addColorStop(0.5, `hsla(0, 100%, 50%, ${life * 0.4})`);
      gradient.addColorStop(1, 'transparent');
      c.strokeStyle = gradient;
      c.lineWidth = 1.5;
      c.beginPath();
      c.moveTo(Math.cos(sa) * size * 0.2, Math.sin(sa) * size * 0.2);
      c.lineTo(Math.cos(sa) * size * 0.9, Math.sin(sa) * size * 0.9);
      c.stroke();
    }
    c.restore();
    
    c.restore();
    
    g.fillStyle = `hsla(0, 100%, 45%, ${life * 0.6})`;
    g.beginPath();
    g.arc(x / 2, y / 2, size / 2, 0, Math.PI * 2);
    g.fill();
  }
}

// === DIVINE ENERGY WAVE ===
function drawDivineEnergyWave(x1, y1, x2, y2, intensity) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const mx = (x1 + x2) / 2;
  const my = (y1 + y2) / 2;
  const angle = Math.atan2(dy, dx);
  const perpX = -Math.sin(angle);
  const perpY = Math.cos(angle);
  
  const waveGroups = 10;
  
  for (let w = 0; w < waveGroups; w++) {
    const waveOffset = (w - waveGroups / 2) * 6;
    const wavePhase = w * 0.8 + Math.sin(time * 1.5 + w) * 0.4;
    const waveSpeed = 5 + w * 0.4;
    
    for (let layer = 4; layer >= 0; layer--) {
      c.save();
      c.beginPath();
      
      const segments = 180;
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const baseX = x1 + dx * t;
        const baseY = y1 + dy * t;
        
        const wave1 = Math.sin(t * Math.PI * 2.5 + time * waveSpeed + wavePhase) * (22 + w * 2) * intensity;
        const wave2 = Math.sin(t * Math.PI * 4.5 + time * (waveSpeed * 1.2) + wavePhase * 1.5) * (14 + w * 1.5) * intensity;
        const wave3 = Math.sin(t * Math.PI * 7 + time * (waveSpeed * 0.8) - wavePhase * 0.6) * (8 + w) * intensity;
        
        const envelope = Math.pow(Math.sin(t * Math.PI), 0.5);
        const totalWave = (wave1 + wave2 + wave3) * envelope + waveOffset;
        
        const px = baseX + perpX * totalWave;
        const py = baseY + perpY * totalWave;
        
        if (i === 0) c.moveTo(px, py);
        else c.lineTo(px, py);
      }
      
      const alpha = intensity * (0.45 - layer * 0.07) * (1 - w * 0.06);
      const hue = 45 - layer * 3 - w * 1.5;
      const sat = 100;
      const light = 55 - layer * 8 - w * 2;
      
      c.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
      c.lineWidth = (10 - layer * 2 - w * 0.4);
      if (layer > 2) c.filter = `blur(${layer * 2}px)`;
      c.lineCap = 'round';
      c.stroke();
      c.filter = 'none';
      c.restore();
    }
  }
  
  [{ x: x1, y: y1 }, { x: x2, y: y2 }].forEach((p, idx) => {
    const orbSize = 35 + intensity * 50;
    const orbPulse = 1 + Math.sin(time * 7 + idx * Math.PI) * 0.12;
    
    for (let i = 5; i >= 0; i--) {
      const layerSize = orbSize * orbPulse * (1 + i * 0.35);
      const gradient = c.createRadialGradient(p.x, p.y, 0, p.x, p.y, layerSize);
      gradient.addColorStop(0, `hsla(50, 100%, 80%, ${intensity * (0.55 - i * 0.08)})`);
      gradient.addColorStop(0.5, `hsla(40, 100%, 60%, ${intensity * (0.35 - i * 0.05)})`);
      gradient.addColorStop(1, 'transparent');
      c.fillStyle = gradient;
      c.beginPath();
      c.arc(p.x, p.y, layerSize, 0, Math.PI * 2);
      c.fill();
    }
  });
  
  if (Math.random() < 0.12 * intensity) {
    const t1 = Math.random() * 0.35;
    const t2 = 0.65 + Math.random() * 0.35;
    const p1x = x1 + dx * t1 + (Math.random() - 0.5) * 40;
    const p1y = y1 + dy * t1 + (Math.random() - 0.5) * 40;
    const p2x = x1 + dx * t2 + (Math.random() - 0.5) * 40;
    const p2y = y1 + dy * t2 + (Math.random() - 0.5) * 40;
    addLightning(p1x, p1y, p2x, p2y, 3, 45 + Math.random() * 15);
  }
  
  g.strokeStyle = `hsla(40, 100%, 45%, ${intensity * 0.45})`;
  g.lineWidth = 30;
  g.lineCap = 'round';
  g.beginPath();
  g.moveTo(x1 / 2, y1 / 2);
  g.lineTo(x2 / 2, y2 / 2);
  g.stroke();
}

// === INSTANCES ===
let leftMandala = null;
let rightMandala = null;

// === UPDATE ===
function update(dt) {
  time += dt;
  
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.vy += 0.15; p.vx *= 0.97; p.vy *= 0.97;
    p.x += p.vx; p.y += p.vy;
    p.life -= dt / p.maxLife;
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  for (let i = sparks.length - 1; i >= 0; i--) {
    const sp = sparks[i];
    sp.trail.push({ x: sp.x, y: sp.y });
    if (sp.trail.length > 15) sp.trail.shift();
    sp.vy += 0.08; sp.vx *= 0.98; sp.vy *= 0.98;
    sp.x += sp.vx; sp.y += sp.vy;
    sp.life -= 0.02;
    if (sp.life <= 0) sparks.splice(i, 1);
  }
  
  for (let i = embers.length - 1; i >= 0; i--) {
    const em = embers[i];
    em.wobble += em.wobbleSpeed * dt;
    em.x += em.vx + Math.sin(em.wobble) * 0.4;
    em.y += em.vy;
    em.vy -= 0.03; em.vx *= 0.99;
    em.life -= 0.012;
    if (em.life <= 0 || em.y < -50) embers.splice(i, 1);
  }
  
  for (let i = lightnings.length - 1; i >= 0; i--) {
    lightnings[i].life -= 0.1;
    if (lightnings[i].life <= 0) lightnings.splice(i, 1);
  }
  
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const sw = shockwaves[i];
    sw.r += (sw.maxR - sw.r) * 0.15;
    sw.life -= 0.04;
    if (sw.life <= 0) shockwaves.splice(i, 1);
  }
  
  if (leftChakra) {
    if (leftChakra.life <= 0) leftChakra = null;
  }
  if (rightChakra) {
    if (rightChakra.life <= 0) rightChakra = null;
  }
  
  bothEyesRedIntensity *= 0.9;
  
  flash *= 0.88;
  shake *= 0.9;
}

// === RENDER ===
function render() {
  c.clearRect(0, 0, W, H);
  s.clearRect(0, 0, W, H);
  e.clearRect(0, 0, W, H);
  g.clearRect(0, 0, W >> 1, H >> 1);
  
  c.save(); s.save(); e.save();
  if (shake > 0.5) {
    const sx = (Math.random() - 0.5) * shake;
    const sy = (Math.random() - 0.5) * shake;
    c.translate(sx, sy); s.translate(sx, sy); e.translate(sx, sy);
  }
  
  shockwaves.forEach(sw => {
    const gradient = c.createRadialGradient(sw.x, sw.y, sw.r * 0.85, sw.x, sw.y, sw.r);
    gradient.addColorStop(0, 'transparent');
    gradient.addColorStop(0.5, `hsla(${sw.color.h}, ${sw.color.s}%, ${sw.color.l}%, ${sw.life * 0.45})`);
    gradient.addColorStop(0.8, `hsla(${sw.color.h}, ${sw.color.s}%, ${sw.color.l + 20}%, ${sw.life * 0.65})`);
    gradient.addColorStop(1, 'transparent');
    c.fillStyle = gradient;
    c.beginPath();
    c.arc(sw.x, sw.y, sw.r, 0, Math.PI * 2);
    c.fill();
  });
  
  // Draw Sudarshan Chakras
  if (leftChakra && leftChakra.life > 0) leftChakra.draw(c);
  if (rightChakra && rightChakra.life > 0) rightChakra.draw(c);
  
  if (leftMandala && leftMandala.life > 0) leftMandala.draw();
  if (rightMandala && rightMandala.life > 0) rightMandala.draw();
  
  if (pullState.active && leftData && rightData) {
    drawDivineEnergyWave(leftData.index.x, leftData.index.y, rightData.index.x, rightData.index.y, pullState.energy);
  }
  
  if (bothEyesRedIntensity > 0.01) {
    if (leftEyeData) drawRedGlowingEye(leftEyeData, e, bothEyesRedIntensity);
    if (rightEyeData) drawRedGlowingEye(rightEyeData, e, bothEyesRedIntensity);
  }
  
  lightnings.forEach(l => {
    if (l.points.length < 2) return;
    for (let layer = 0; layer < 3; layer++) {
      s.beginPath();
      s.moveTo(l.points[0].x, l.points[0].y);
      l.points.forEach(p => s.lineTo(p.x, p.y));
      if (layer === 0) { s.strokeStyle = `hsla(${l.hue}, 100%, 40%, ${l.life * 0.35})`; s.lineWidth = 9; s.filter = 'blur(5px)'; }
      else if (layer === 1) { s.strokeStyle = `hsla(${l.hue}, 100%, 60%, ${l.life * 0.65})`; s.lineWidth = 4; s.filter = 'blur(2px)'; }
      else { s.strokeStyle = `hsla(${l.hue}, 100%, 92%, ${l.life})`; s.lineWidth = 1.8; s.filter = 'none'; }
      s.stroke();
      s.filter = 'none';
    }
  });
  
  embers.forEach(em => {
    const flicker = Math.sin(time * em.wobbleSpeed * 3 + em.wobble) * 0.3 + 0.7;
    const emberGrad = s.createRadialGradient(em.x, em.y, 0, em.x, em.y, em.size * 2);
    emberGrad.addColorStop(0, `hsla(${em.hue + 10}, 100%, 80%, ${em.life * flicker})`);
    emberGrad.addColorStop(0.4, `hsla(${em.hue}, 100%, 55%, ${em.life * flicker * 0.5})`);
    emberGrad.addColorStop(1, 'transparent');
    s.fillStyle = emberGrad;
    s.beginPath();
    s.arc(em.x, em.y, em.size * 2, 0, Math.PI * 2);
    s.fill();
  });
  
  sparks.forEach(sp => {
    if (sp.trail.length > 1) {
      for (let i = 1; i < sp.trail.length; i++) {
        const t = i / sp.trail.length;
        s.strokeStyle = `hsla(${sp.hue}, 100%, 70%, ${t * sp.life * 0.7})`;
        s.lineWidth = sp.size * t * 1.2;
        s.lineCap = 'round';
        s.beginPath();
        s.moveTo(sp.trail[i-1].x, sp.trail[i-1].y);
        s.lineTo(sp.trail[i].x, sp.trail[i].y);
        s.stroke();
      }
    }
    
    const flicker = Math.sin(time * sp.flickerSpeed) * 0.3 + 0.7;
    const sparkGrad = s.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, sp.size * 3);
    sparkGrad.addColorStop(0, `hsla(${sp.hue}, 100%, 90%, ${sp.life * flicker})`);
    sparkGrad.addColorStop(0.4, `hsla(${sp.hue}, 100%, 60%, ${sp.life * flicker * 0.4})`);
    sparkGrad.addColorStop(1, 'transparent');
    s.fillStyle = sparkGrad;
    s.beginPath();
    s.arc(sp.x, sp.y, sp.size * 3, 0, Math.PI * 2);
    s.fill();
  });
  
  particles.forEach(p => {
    const alpha = Math.min(1, p.life * 2);
    const size = p.size * p.life;
    const flicker = Math.sin(time * 10 + p.flickerPhase) * 0.2 + 0.8;
    
    const grad = c.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
    grad.addColorStop(0, `hsla(${p.hue + 10}, 100%, 85%, ${alpha * flicker})`);
    grad.addColorStop(0.3, `hsla(${p.hue}, 100%, 60%, ${alpha * flicker * 0.5})`);
    grad.addColorStop(1, 'transparent');
    c.fillStyle = grad;
    c.beginPath();
    c.arc(p.x, p.y, size, 0, Math.PI * 2);
    c.fill();
  });
  
  c.restore(); s.restore(); e.restore();
  
  if (flash > 0.01) {
    c.fillStyle = `hsla(45, 100%, 70%, ${flash * 0.35})`;
    c.fillRect(0, 0, W, H);
  }
}

// === PROCESS HANDS ===
function processHands() {
  leftData = getHandData(leftHand);
  rightData = getHandData(rightHand);
  
  let gestureText = 'None';
  if (leftData) gestureText = `L: ${leftData.gesture}`;
  if (rightData) gestureText += ` R: ${rightData.gesture}`;
  document.getElementById('gestureType').textContent = gestureText;
  
  let leftVel = 0, rightVel = 0;
  if (leftData && prevLeftPos) leftVel = Math.hypot(leftData.index.x - prevLeftPos.x, leftData.index.y - prevLeftPos.y);
  if (rightData && prevRightPos) rightVel = Math.hypot(rightData.index.x - prevRightPos.x, rightData.index.y - prevRightPos.y);
  
  prevLeftPos = leftData ? { x: leftData.index.x, y: leftData.index.y } : null;
  prevRightPos = rightData ? { x: rightData.index.x, y: rightData.index.y } : null;
  
  const leftPointing = leftData && leftData.gesture === 'pointing';
  const rightPointing = rightData && rightData.gesture === 'pointing';
  const bothPointing = leftPointing && rightPointing;
  
  const leftPalm = leftData && leftData.gesture === 'openPalm';
  const rightPalm = rightData && rightData.gesture === 'openPalm';
  const bothPalms = leftPalm && rightPalm;
  
  // === SUDARSHAN CHAKRA - appears when pointing (not both) ===
  const wasLeftChakraActive = leftChakraActive;
  const wasRightChakraActive = rightChakraActive;
  
  if (leftPointing && !bothPointing) {
    if (!leftChakra || leftChakra.life <= 0) {
      leftChakra = new SudarshanChakra(leftData.index.x, leftData.index.y, true);
      audio.init();
      audio.playChakraSound();
    }
    leftChakra.update(leftData.index.x, leftData.index.y, true);
    audio.updateChakraSound(1);
    leftChakraActive = true;
  } else {
    if (leftChakra) leftChakra.update(leftChakra.x, leftChakra.y, false);
    if (wasLeftChakraActive && !leftPointing) {
      audio.stopChakraSound();
    }
    leftChakraActive = false;
  }
  
  if (rightPointing && !bothPointing) {
    if (!rightChakra || rightChakra.life <= 0) {
      rightChakra = new SudarshanChakra(rightData.index.x, rightData.index.y, false);
      if (!leftChakraActive) {
        audio.init();
        audio.playChakraSound();
      }
    }
    rightChakra.update(rightData.index.x, rightData.index.y, true);
    if (!leftChakraActive) audio.updateChakraSound(1);
    rightChakraActive = true;
  } else {
    if (rightChakra) rightChakra.update(rightChakra.x, rightChakra.y, false);
    if (wasRightChakraActive && !rightPointing && !leftChakraActive) {
      audio.stopChakraSound();
    }
    rightChakraActive = false;
  }
  
  // === SHIELDS ===
  const wasLeftActive = leftShieldActive;
  const wasRightActive = rightShieldActive;
  
  if (leftPalm) {
    const size = Math.max(140, leftData.palmSize * 2.8);
    if (!leftMandala || leftMandala.life <= 0) leftMandala = new Mandala(leftData.palm.x, leftData.palm.y, size, true);
    else leftMandala.update(leftData.palm.x, leftData.palm.y, size, true);
    if (!wasLeftActive) { audio.init(); audio.playShieldSound('left'); }
    leftShieldActive = true;
  } else {
    if (leftMandala && leftMandala.life > 0) leftMandala.update(leftMandala.x, leftMandala.y, leftMandala.size, false);
    leftShieldActive = false;
  }
  
  if (rightPalm) {
    const size = Math.max(140, rightData.palmSize * 2.8);
    if (!rightMandala || rightMandala.life <= 0) rightMandala = new Mandala(rightData.palm.x, rightData.palm.y, size, false);
    else rightMandala.update(rightData.palm.x, rightData.palm.y, size, true);
    if (!wasRightActive) { audio.init(); audio.playShieldSound('right'); }
    rightShieldActive = true;
  } else {
    if (rightMandala && rightMandala.life > 0) rightMandala.update(rightMandala.x, rightMandala.y, rightMandala.size, false);
    rightShieldActive = false;
  }
  
  // === BOTH EYES RED only when BOTH palms are open ===
  if (bothPalms) {
    bothEyesRedIntensity = 1;
  }
  
  // === DIVINE ENERGY WAVE + BLAST ===
  pullState.active = false;
  
  const powerMeter = document.getElementById('powerMeter');
  const powerFill = document.getElementById('powerFill');
  
  if (bothPointing) {
    // Turn off individual chakras when both pointing
    if (leftChakra) leftChakra.update(leftChakra.x, leftChakra.y, false);
    if (rightChakra) rightChakra.update(rightChakra.x, rightChakra.y, false);
    audio.stopChakraSound();
    
    const dist = Math.hypot(leftData.index.x - rightData.index.x, leftData.index.y - rightData.index.y);
    
    if (dist > 60 && dist < 1000) {
      pullState.active = true;
      pullState.distance = dist;
      pullState.energy = Math.min(1, (dist - 60) / 600);
      pullState.peakEnergy = Math.max(pullState.peakEnergy, pullState.energy);
      
      powerMeter.classList.add('active');
      powerFill.style.width = (pullState.energy * 100) + '%';
      
      if (!pullState.wasActive) {
        audio.init();
        audio.startEnergySound();
      }
      audio.updateEnergySound(pullState.energy);
      
      pullState.wasActive = true;
    } else if (dist >= 1000 && pullState.wasActive && pullState.peakEnergy > 0.25) {
      audio.stopEnergySound();
      const cx = (leftData.index.x + rightData.index.x) / 2;
      const cy = (leftData.index.y + rightData.index.y) / 2;
      triggerExplosion(cx, cy, pullState.peakEnergy);
      
      pullState.energy = 0;
      pullState.peakEnergy = 0;
      pullState.wasActive = false;
      powerMeter.classList.remove('active');
    } else {
      if (pullState.wasActive) audio.stopEnergySound();
      pullState.energy = 0;
      pullState.peakEnergy = 0;
      pullState.wasActive = false;
      powerMeter.classList.remove('active');
    }
  } else {
    if (pullState.wasActive && pullState.peakEnergy > 0.25 && (leftVel > 25 || rightVel > 25)) {
      audio.stopEnergySound();
      
      let cx = W / 2, cy = H / 2;
      if (leftData) { cx = leftData.index.x; cy = leftData.index.y; }
      else if (rightData) { cx = rightData.index.x; cy = rightData.index.y; }
      
      triggerExplosion(cx, cy, pullState.peakEnergy);
    } else if (pullState.wasActive) {
      audio.stopEnergySound();
    }
    
    pullState.wasActive = false;
    pullState.energy = 0;
    pullState.peakEnergy *= 0.95;
    powerMeter.classList.remove('active');
  }
}

// === ANIMATION LOOP ===
let lastTime = 0;

function loop(now) {
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  
  frames++;
  if (now - lastSec >= 1000) {
    document.getElementById('fps').textContent = frames;
    frames = 0;
    lastSec = now;
  }
  
  processHands();
  update(dt);
  render();
  
  requestAnimationFrame(loop);
}

// === MEDIAPIPE ===
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
hands.onResults(res => {
  leftHand = null; rightHand = null;
  if (res.multiHandLandmarks && res.multiHandedness) {
    for (let i = 0; i < res.multiHandLandmarks.length; i++) {
      const label = res.multiHandedness[i].label;
      if (label === 'Right') leftHand = res.multiHandLandmarks[i];
      else rightHand = res.multiHandLandmarks[i];
    }
  }
});

const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
faceMesh.onResults(res => {
  if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
    faceData = res.multiFaceLandmarks[0];
    const eyes = getDetailedEyeData(faceData);
    leftEyeData = eyes.left; rightEyeData = eyes.right;
  } else { faceData = null; leftEyeData = null; rightEyeData = null; }
});

const camera = new Camera(cam, {
  onFrame: async () => { await hands.send({ image: cam }); await faceMesh.send({ image: cam }); },
  width: 1280, height: 720
});

camera.start().then(() => {
  setTimeout(() => { document.getElementById('loader').classList.add('hide'); requestAnimationFrame(loop); }, 2000);
});
</script>
</body>
</html>